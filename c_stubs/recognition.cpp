/* USAGE INFOS

 - Nella directory in cui è presente questa libreria dev'essere presente una directory 'haarcascades\'
    contenente i file xml con le informazioni necessarie ai vari classificatori

 - Per utilizzare i diversi classificatori è necessario attivarli, impostando a "true" le macro
    USING_ definite poco più in basso

 - Per visualizzare le informazioni di debug nel file di log bisogna impostare il valore della macro
	LOG_LEVEL a DEBUG

 - Per salvare le immagini relative alla porzione di immagine in cui viene effettuata la detezione da
	parte dei vari classificatori, è necessario impostare il valore della macro LOG_LEVEL a EVERYTHING_ENABLED

*/

/*
Codes for error generated by unpredictable situations that may occur during execution
This error codes will be written in the log file unless the program crashes

-- 1xx GASPARE ------------------------------

 -- detection -------------------------------
  101 ff_classifier try-catch undefined error
  102 pf_classifier try-catch undefined error
  103 fb_classifier try-catch undefined error
  104 ub_classifier try-catch undefined error
  105 lb_classifier try-catch undefined error

 -- identifying -----------------------------
*/

#include "recognition.h"
#include <iostream>
#include <opencv2/opencv.hpp>

// -------------------------------------------------------------------------------------------------
// Inclusion of some opencv libraries
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/imgproc/imgproc.hpp>

// Some macros with names of classifiers used to detect the user
#define FRONTAL_FACE_MODEL "haarcascades\\haarcascade_frontalface_alt2.xml"
#define PROFILE_FACE_MODEL "haarcascades\\haarcascade_profileface.xml"
#define FULL_BODY_MODEL    "haarcascades\\haarcascade_fullbody.xml"
#define UPPER_BODY_MODEL   "haarcascades\\haarcascade_upperbody.xml"
#define LOWER_BODY_MODEL   "haarcascades\\haarcascade_lowerbody.xml"

#define USING_FF_CLASSIFIER false
#define USING_PF_CLASSIFIER false
#define USING_FB_CLASSIFIER false
#define USING_UB_CLASSIFIER true
#define USING_LB_CLASSIFIER false

// LOG FILE
#define LOG_FILE_NAME    "log_recognition_dll.txt"								// Name of the log file
#define DATE_TIME_FORMAT "%y-%m-%d %I:%M%p "									// Format to use to write date and time to the log file

// Set of possible log levels
enum LOG_LINE_LEVEL { EVERYTHING_ENABLED	=   0 ,
					  DEBUG					=   5 ,
					  WARNING				=  10 ,
					  ERROR					=  15 ,
					  NO_LOG				= 100 };

// LOG_LEVEL indicates the minimum line level for which it will be written a line to the log file
const enum LOG_LINE_LEVEL LOG_LEVEL = DEBUG;

// getCurrentDateTime() returns a string containing current date and time formatted like DATE_TIME_FORMAT
std::string getCurrentDateTime();

// writeLog() writes a line to the log file like: "<date and time> [llevel] - <text>"
void writeLog(std::string & text, enum LOG_LINE_LEVEL llevel = DEBUG);

// Prototype for the fuctions used to detect people
void detectPeople(cv::Mat);
void setup();
// -------------------------------------------------------------------------------------------------

void kinematicInfo(float *speed, float *acc, float *angular, float *angularAcc, float delta)
{
	*speed = 0;
	*acc = 0;
	*angular = 0;
	*angularAcc = 0;
}

void captureImage(unsigned char *pixelData, int w, int h, int stride, bool isLeft, float delta)
{
	cv::Mat cam(h, w, CV_8UC3, pixelData);
	cv::Mat flipped;
	cv::flip(cam, flipped, 0);
	cv::cvtColor(flipped, flipped, cv::COLOR_RGB2BGR);

	//cv::imwrite(isLeft ? "leftcam.jpg" : "rightcam.jpg", flipped);	//DO NOT ENABLE THIS UNLESS FOR TESTING PURPOSE!

	// -------------------------------------------------------------------------------------------------
	if(isLeft) detectPeople(flipped);
	// -------------------------------------------------------------------------------------------------
}

// -------------------------------------------------------------------------------------------------
void detectPeople(cv::Mat frame_in)
{
	using namespace std;
	using namespace cv;

	// The actual classifiers
	static cv::CascadeClassifier ff_classifier; // frontal face classifier
	static cv::CascadeClassifier pf_classifier; // profile face classifier
	static cv::CascadeClassifier fb_classifier; // full body classifier
	static cv::CascadeClassifier ub_classifier; // upper body classifier
	static cv::CascadeClassifier lb_classifier; // lower body classifier

	// DEBUG: The output frame used to see detection results
	Mat frame_out;

	// Vectors of rects returned by the classifiers
	vector<Rect> ff_detected;
	vector<Rect> pf_detected;
	vector<Rect> fb_detected;
	vector<Rect> ub_detected;
	vector<Rect> lb_detected;
	
	// this code section must stay here untill simulator doesn't call setup()
	{
		// Quit application unless loading classifier models can be completed
		if (USING_FF_CLASSIFIER && ff_classifier.empty())
		{	
			string temp_str = string("trying to load: ") + string(FRONTAL_FACE_MODEL);
			writeLog(temp_str);

			if (!ff_classifier.load(FRONTAL_FACE_MODEL))
			{
				writeLog(string("Error loading ff_model!"), ERROR);
				assert(false);
			}
			else { writeLog(string("ff_model loaded correctly")); }
		}
		
		if (USING_PF_CLASSIFIER && pf_classifier.empty())
		{
			string temp_str = string("trying to load: ") + string(PROFILE_FACE_MODEL);
			writeLog(temp_str);

			if (!pf_classifier.load(PROFILE_FACE_MODEL))
			{
				writeLog(string("Error loading pf_model!"), ERROR);
				assert(false);
			}
			else { writeLog(string("pf_model loaded correctly")); }

			writeLog(string("-------------------------------------------------------------------------------------"));
		}

		if (USING_FB_CLASSIFIER && fb_classifier.empty())
		{
			string temp_str = string("trying to load: ") + string(FULL_BODY_MODEL);
			writeLog(temp_str);

			if (!fb_classifier.load(FULL_BODY_MODEL))
			{
				writeLog(string("Error loading fb_model!"), ERROR);
				assert(false);
			}
			else { writeLog(string("fb_model loaded correctly")); }

			writeLog(string("-------------------------------------------------------------------------------------"));
		}

		if (USING_UB_CLASSIFIER && ub_classifier.empty())
		{
			string temp_str = string("trying to load: ") + string(UPPER_BODY_MODEL);
			writeLog(temp_str);

			if (!ub_classifier.load(UPPER_BODY_MODEL))
			{
				writeLog(string("Error loading ub_model!"), ERROR);
				assert(false);
			}
			else { writeLog(string("ub_model loaded correctly")); }

			writeLog(string("-------------------------------------------------------------------------------------"));
		}

		if (USING_LB_CLASSIFIER && lb_classifier.empty())
		{
			string temp_str = string("trying to load: ") + string(LOWER_BODY_MODEL);
			writeLog(temp_str);

			if (!lb_classifier.load(LOWER_BODY_MODEL))
			{
				writeLog(string("Error loading lb_model!"), ERROR);
				assert(false);
			}
			else { writeLog(string("lb_model loaded correctly")); }

			writeLog(string("-------------------------------------------------------------------------------------"));
		}
	}
	
	if (frame_in.empty())
	{
		writeLog(string("Received an empty frame!!"), WARNING);
		return;
	}

	cvtColor(frame_in, frame_in, COLOR_BGR2GRAY);
	equalizeHist(frame_in, frame_in);
	writeLog(string("converted input image from BGR to grayscale"));

	if (USING_FF_CLASSIFIER)
	{
		ostringstream oss;

		try
		{
			//ff_classifier.detectMultiScale(frame_in, ff_detected, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
			ff_classifier.detectMultiScale(frame_in, ff_detected, 1.1, 2);
			
			oss << "detected ";
			oss << ff_detected.size();
			oss << " faces using ff classifier";
			writeLog(oss.str());
		}
		catch (cv::Exception e)
		{
			oss << "ff_classifier.detectMultiScale thrown: ";
			oss << e.err;
			writeLog(oss.str(), ERROR);
		}
		catch (...)
		{
			writeLog(string("Something wrong appened (error code: 101)..."), ERROR);
		}

		static unsigned int tot_det_ff = 0;

		for (size_t i = 0; i < ff_detected.size(); ++i)
		{
			ostringstream file_name;
			file_name << "detection_ff_";
			file_name << (++tot_det_ff < 10 ? "0" : "");
			file_name << tot_det_ff;
			file_name << ".jpg";

			if (LOG_LEVEL == EVERYTHING_ENABLED)
			{
				imwrite(file_name.str(), frame_in(ff_detected.at(i)));
				writeLog("written: " + file_name.str());
			}
		}
	}

	if (USING_PF_CLASSIFIER)
	{
		ostringstream oss;

		try
		{
			//pf_classifier.detectMultiScale(frame_in, ff_faces, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
			pf_classifier.detectMultiScale(frame_in, pf_detected, 1.1, 2);
			
			oss << "detected ";
			oss << ff_detected.size();
			oss << " faces using ff classifier";
			writeLog(oss.str());
		}
		catch (cv::Exception e)
		{
			oss << "pf_classifier.detectMultiScale thrown: ";
			oss << e.err;
			writeLog(oss.str(), ERROR);
		}
		catch (...)
		{
			writeLog(string("Something wrong appened (error code: 102)..."), ERROR);
		}

		static unsigned int tot_det_pf = 0;

		for (size_t i = 0; i < pf_detected.size(); ++i)
		{
			ostringstream file_name;
			file_name << "detection_pf_";
			file_name << (++tot_det_pf < 10 ? "0" : "");
			file_name << tot_det_pf;
			file_name << ".jpg";

			if (LOG_LEVEL == EVERYTHING_ENABLED)
			{
				imwrite(file_name.str(), frame_in(pf_detected.at(i)));
				writeLog("written: " + file_name.str());
			}
		}
	}

	if (USING_FB_CLASSIFIER)
	{
		ostringstream oss;
		try
		{
			//fb_classifier.detectMultiScale(frame_in, fb_detected, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
			fb_classifier.detectMultiScale(frame_in, fb_detected, 1.1, 2);
			
			oss << "detected ";
			oss << fb_detected.size();
			oss << " bodies using fb classifier";
			writeLog(oss.str());
		}
		catch (cv::Exception e)
		{
			oss << "fb_classifier.detectMultiScale thrown: ";
			oss << e.err;
			writeLog(oss.str(), ERROR);
		}
		catch (...)
		{
			writeLog(string("Something wrong appened (error code: 103)..."), ERROR);
		}

		static unsigned int tot_det_fb = 0;

		for (size_t i = 0; i < fb_detected.size(); ++i)
		{
			ostringstream file_name;
			file_name << "detection_fb_";
			file_name << (++tot_det_fb < 10 ? "0" : "");
			file_name << tot_det_fb;
			file_name << ".jpg";

			if (LOG_LEVEL == EVERYTHING_ENABLED)
			{
				imwrite(file_name.str(), frame_in(fb_detected.at(i)));
				writeLog("written: " + file_name.str());
			}
		}
	}
	
	if (USING_UB_CLASSIFIER)
	{
		ostringstream oss;
		try
		{
			//ub_classifier.detectMultiScale(frame_in, ub_detected, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
			ub_classifier.detectMultiScale(frame_in, ub_detected, 1.1, 2);

			oss << "detected ";
			oss << ub_detected.size();
			oss << " bodies using ub classifier";
			writeLog(oss.str());
		}
		catch (cv::Exception e)
		{
			oss << "ub_classifier.detectMultiScale thrown: ";
			oss << e.err;
			writeLog(oss.str(), ERROR);
		}
		catch (...)
		{
			writeLog(string("Something wrong appened (error code: 104)..."), ERROR);
		}

		static unsigned int tot_det_ub = 0;

		for (size_t i = 0; i < ub_detected.size(); ++i)
		{
			ostringstream file_name;
			file_name << "detection_ub_";
			file_name << (++tot_det_ub < 10 ? "0" : "");
			file_name << tot_det_ub;
			file_name << ".jpg";

			if (LOG_LEVEL == EVERYTHING_ENABLED)
			{
				imwrite(file_name.str(), frame_in(ub_detected.at(i)));
				writeLog("written: " + file_name.str());
			}
		}
	}

	if (USING_LB_CLASSIFIER)
	{
		ostringstream oss;
		try
		{
			//lb_classifier.detectMultiScale(frame_in, lb_detected, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
			lb_classifier.detectMultiScale(frame_in, lb_detected, 1.1, 2);

			oss << "detected ";
			oss << lb_detected.size();
			oss << " bodies using lb classifier";
			writeLog(oss.str());
		}
		catch (cv::Exception e)
		{
			oss << "lb_classifier.detectMultiScale thrown: ";
			oss << e.err;
			writeLog(oss.str(), ERROR);
		}
		catch (...)
		{
			writeLog(string("Something wrong appened (error code: 105)..."), ERROR);
		}

		static unsigned int tot_det_lb = 0;

		for (size_t i = 0; i < lb_detected.size(); ++i)
		{
			ostringstream file_name;
			file_name << "detection_lb_";
			file_name << (++tot_det_lb < 10 ? "0" : "");
			file_name << tot_det_lb;
			file_name << ".jpg";

			if (LOG_LEVEL == EVERYTHING_ENABLED)
			{
				imwrite(file_name.str(), frame_in(lb_detected.at(i)));
				writeLog("written: " + file_name.str());
			}
		}
	}

	//imwrite("output_image.jpg", frame_out);

	writeLog(string("-------------------------------------------------------------------------------------"));
}

void writeLog(std::string & text, enum LOG_LINE_LEVEL llevel)
{
	using namespace std;
	
	// Do not write if LOG_LEVEL is greater than the line level
	if (llevel < LOG_LEVEL) return;

	// Prepare a string with an indication of the line level
	string log_level;
	switch (llevel)
	{
	case DEBUG:
		log_level = "[D]";
		break;
	case WARNING:
		log_level = "[W]";
		break;
	case ERROR:
		log_level = "[E]";
		break;
	case NO_LOG:
	default: // Shouldn't be triggered
		log_level = "[]";
		break;
	}
	
	// Open a stream to the log file
	ofstream log_file(LOG_FILE_NAME, ios_base::out | ios_base::app);
	log_file << getCurrentDateTime();	// write the current date and time
	log_file << log_level;				// write the line level
	log_file << " - ";					// write a separator
	log_file << text;					// write the log text
	log_file << endl;					// flush
}

std::string getCurrentDateTime()
{
	const int buff_size = 80;
	time_t rawtime;
	struct tm * timeinfo;
	char st[buff_size];

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(st, buff_size, DATE_TIME_FORMAT, timeinfo);

	return st;
}

void setup()
{
	using namespace std;

	ofstream log_file(LOG_FILE_NAME, ios_base::out);
	log_file << endl;

	// 0 - open log file
	// 1 - setup the classifiers
	// 2 - complete initial setup
}
// -------------------------------------------------------------------------------------------------