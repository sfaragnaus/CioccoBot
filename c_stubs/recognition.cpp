/* USAGE INFOS (IT)

 -- log -------------------------------------
 - Per visualizzare le informazioni di debug nel file di log bisogna impostare il valore della macro
	LOG_LEVEL a DEBUG

 - Per salvare le immagini è necessario impostare il valore della macro LOG_LEVEL a EVERYTHING_ENABLED

 -- detection -------------------------------
 - Nella directory in cui è presente questa libreria dev'essere presente una directory 'haarcascades\'
    contenente i file xml con le informazioni necessarie ai vari classificatori

 - Per utilizzare i diversi classificatori è necessario attivarli, impostando a "true" le macro
    USING_xx_CLASSIFIER

 -- identifying -----------------------------
 -- tracking --------------------------------
*/

/*
Codes for error generated by unpredictable situations that may occur during execution
This error codes will be written in the log file unless the program crashes

-- 1xx GASPARE ------------------------------

 -- detection -------------------------------
  101 - FF_ERROR_CODE - ff_classifier try-catch undefined error
  102 - PF_ERROR_CODE - pf_classifier try-catch undefined error
  103 - FB_ERROR_CODE - fb_classifier try-catch undefined error
  104 - UB_ERROR_CODE - ub_classifier try-catch undefined error
  105 - LB_ERROR_CODE - lb_classifier try-catch undefined error

 -- identifying -----------------------------
 -- tracking --------------------------------
*/

#include "recognition.h"
#include <iostream>
#include <opencv2/opencv.hpp>

// Inclusion of some opencv libraries
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/imgproc/imgproc.hpp>

// Macros defining the names of classifiers used to detect the people
#define FRONTAL_FACE_MODEL "haarcascades\\haarcascade_frontalface_alt2.xml" // ff_model relative path
#define PROFILE_FACE_MODEL "haarcascades\\haarcascade_profileface.xml"      // pf_model relative path
#define FULL_BODY_MODEL    "haarcascades\\haarcascade_fullbody.xml"         // fb_model relative path
#define UPPER_BODY_MODEL   "haarcascades\\haarcascade_upperbody.xml"        // ub_model relative path
#define LOWER_BODY_MODEL   "haarcascades\\haarcascade_lowerbody.xml"        // lb_model relative path

// Macros that enable classifiers
#define USING_FF_CLASSIFIER false
#define USING_PF_CLASSIFIER false
#define USING_FB_CLASSIFIER false
#define USING_UB_CLASSIFIER true
#define USING_LB_CLASSIFIER false

// Error codes written by the detection algorithm
#define FF_ERROR_CODE 101 // ff_classifier try-catch undefined error
#define PF_ERROR_CODE 102 // pf_classifier try-catch undefined error
#define FB_ERROR_CODE 103 // fb_classifier try-catch undefined error
#define UB_ERROR_CODE 104 // ub_classifier try-catch undefined error
#define LB_ERROR_CODE 105 // lb_classifier try-catch undefined error

// NB: attualmente viene definita ma non utilizzata, in attesa che l'algoritmo venga implementato
// Values used by the tracking algorithm to follow the user
#define POSITION_DELTA   1.0f // [m] represents the distance from the user that must be reached
#define POSITION_EPSILON 0.1f // [m] represents the maximum acceptable positioning error

/*
	The distance from an object is computed using the formula:
	 <distance> = <distance between cameras> * <focal length> / <disparity>
	where disparity is the distance in pixels between the same point in the two pictures
*/
#define DISTANCE_BETWEEN_CAMERAS 0.04f // [m] Distance between the two cameras
#define CAMERAS_FOCAL_LENGHT	 0.02f // [m] focal length of the two cameras (PS: must be the same)

// LOG FILE
#define LOG_FILE_NAME    "log_recognition_dll.txt" // Name of the log file
#define DATE_TIME_FORMAT "%y-%m-%d %I:%M%p "       // Format to use to write date and time to the log file

#define PX2M(px_val) (px_val * 0.000265f) // Converts a value from pixels to meters

#define LOG_DIV_LINE writeLog(std::string("-------------------------------------------------------------------------------------"), FORMAT);

// Set of possible log levels
enum LOG_LINE_LEVEL { EVERYTHING_ENABLED	=   0 ,  // Enable all possible debug log (including img saving)
					  DEBUG					=   5 ,  // Enable all log text lines
					  WARNING				=  10 ,  // Enable only log text lines marked as warning or error
					  ERROR					=  15 ,  // Enable only log text lines marked as error
					  FORMAT                =  95 ,  // Write log text lines used to make the log file much readable
					  NO_LOG				= 100 }; // Donìt write the log file at all

// LOG_LEVEL indicates the minimum line level for which it will be written a line to the log file
const enum LOG_LINE_LEVEL LOG_LEVEL = WARNING;

// getCurrentDateTime() returns a string containing current date and time formatted like DATE_TIME_FORMAT
std::string getCurrentDateTime();

// writeLog() writes a line to the log file like: "<date and time> [llevel] - <text>"
void writeLog(std::string & text, enum LOG_LINE_LEVEL llevel = DEBUG);

// The actual classifiers
cv::CascadeClassifier ff_classifier; // frontal face classifier
cv::CascadeClassifier pf_classifier; // profile face classifier
cv::CascadeClassifier fb_classifier; // full body classifier
cv::CascadeClassifier ub_classifier; // upper body classifier
cv::CascadeClassifier lb_classifier; // lower body classifier

// Vectors of rects returned by the classifiers
std::vector<cv::Rect> ff_detected_l, ff_detected_r; // frontal faces detected
std::vector<cv::Rect> pf_detected_l, pf_detected_r; // profile faces detected
std::vector<cv::Rect> fb_detected_l, fb_detected_r; // full bodies   detected
std::vector<cv::Rect> ub_detected_l, ub_detected_r; // upper bodies  detected
std::vector<cv::Rect> lb_detected_l, lb_detected_r; // lower bodies  detected

unsigned int tot_det_ff_l, tot_det_pf_l, tot_det_fb_l, tot_det_ub_l, tot_det_lb_l; // total detections counter (left)
unsigned int tot_det_ff_r, tot_det_pf_r, tot_det_fb_r, tot_det_ub_r, tot_det_lb_r; // total detections counter (right)

// Prototype for the fuctions used to detect people
void detectPeople(cv::Mat, cv::Mat);

bool setupClassifier(cv::CascadeClassifier & classifier, std::string model, std::string cname_for_log);
std::vector<cv::Rect> detectWithClassifier(cv::Mat frame, cv::CascadeClassifier & cclassifier, std::string short_name_for_log, unsigned int * tot_det, int ecode);

bool setup(void)
{
	// Open the log file unless LOG_LEVEL is NO_LOG
	if (LOG_LEVEL < NO_LOG)
	{
		std::ofstream log_file(LOG_FILE_NAME, std::ios_base::out);
		log_file << std::endl;
	}

	// Try to load the models into the classifiers
	if (USING_FF_CLASSIFIER && !setupClassifier(ff_classifier, FRONTAL_FACE_MODEL, "ff_model")) return false;
	if (USING_PF_CLASSIFIER && !setupClassifier(pf_classifier, PROFILE_FACE_MODEL, "pf_model")) return false;
	if (USING_FB_CLASSIFIER && !setupClassifier(fb_classifier, FULL_BODY_MODEL   , "fb_model")) return false;
	if (USING_UB_CLASSIFIER && !setupClassifier(ub_classifier, UPPER_BODY_MODEL  , "ub_model")) return false;
	if (USING_LB_CLASSIFIER && !setupClassifier(lb_classifier, LOWER_BODY_MODEL  , "lb_model")) return false;

	// Initialyze total detection counters to 0
	tot_det_ff_l = tot_det_pf_l = tot_det_fb_l = tot_det_ub_l = tot_det_lb_l = 0;
	tot_det_ff_r = tot_det_pf_r = tot_det_fb_r = tot_det_ub_r = tot_det_lb_r = 0;
	
	return true;
}

void kinematicInfo(float *speed, float *acc, float *angular, float *angularAcc, float delta)
{
	*speed = 0;
	*acc = 0;
	*angular = 0;
	*angularAcc = 0;
}

void test(cv::Mat l_img, cv::Mat r_img)
{
	// convert color to grayscale
	cv::cvtColor(l_img, l_img, cv::COLOR_BGR2GRAY);
	cv::cvtColor(r_img, r_img, cv::COLOR_BGR2GRAY);

	if (ub_detected_l.size() && ub_detected_r.size())
	{
		writeLog(std::string("Detected something on both picture, trying to compute distance"));
		
		float x1 = ub_detected_l.at(0).x + ub_detected_l.at(0).width / 2;
		float x2 = ub_detected_r.at(0).x + ub_detected_r.at(0).width / 2;
		
		float disparity = abs(x1 - x2);

		float distance = DISTANCE_BETWEEN_CAMERAS * CAMERAS_FOCAL_LENGHT / PX2M(disparity);
		
		std::ostringstream oss;
		oss << "computed distance: " << distance << " m";
		writeLog(oss.str());
	}

}

void captureImage(unsigned char *pixelDataSx, unsigned char *pixelDataDx, int w, int h, int stride, float delta)
{
	//sx cam
	cv::Mat camSx(h, w, CV_8UC3, pixelDataSx);
	cv::Mat flippedSx;
	cv::flip(camSx, flippedSx, 0);
	cv::cvtColor(flippedSx, flippedSx, cv::COLOR_RGB2BGR);

	//dx cam
	cv::Mat camDx(h, w, CV_8UC3, pixelDataDx);
	cv::Mat flippedDx;
	cv::flip(camDx, flippedDx, 0);
	cv::cvtColor(flippedDx, flippedDx, cv::COLOR_RGB2BGR);

	if (LOG_LEVEL == EVERYTHING_ENABLED)
	{
		cv::imwrite("leftcam.jpg", flippedSx);
		cv::imwrite("rightcam.jpg", flippedDx);
	}

	detectPeople(flippedSx, flippedDx);

	test(flippedSx, flippedDx);

	LOG_DIV_LINE;
}

void detectPeople(cv::Mat frame_l, cv::Mat frame_r)
{	
	if (frame_l.empty() || frame_r.empty())
	{
		writeLog(std::string("Received an empty frame!!"), WARNING);
		return;
	}

	cv::cvtColor(frame_l, frame_l, cv::COLOR_BGR2GRAY);
	cv::equalizeHist(frame_l, frame_l);
	writeLog(std::string("converted input image (L) from BGR to grayscale"));

	cv::cvtColor(frame_r, frame_r, cv::COLOR_BGR2GRAY);
	cv::equalizeHist(frame_r, frame_r);
	writeLog(std::string("converted input image (R) from BGR to grayscale"));

	// detect people in the left image
	if (USING_FF_CLASSIFIER) ff_detected_l = detectWithClassifier(frame_l, ff_classifier, "ff", &tot_det_ff_l, FF_ERROR_CODE);
	if (USING_PF_CLASSIFIER) pf_detected_l = detectWithClassifier(frame_l, pf_classifier, "pf", &tot_det_pf_l, PF_ERROR_CODE);
	if (USING_FB_CLASSIFIER) fb_detected_l = detectWithClassifier(frame_l, fb_classifier, "fb", &tot_det_fb_l, FB_ERROR_CODE);
	if (USING_UB_CLASSIFIER) ub_detected_l = detectWithClassifier(frame_l, ub_classifier, "ub", &tot_det_ub_l, UB_ERROR_CODE);
	if (USING_LB_CLASSIFIER) lb_detected_l = detectWithClassifier(frame_l, lb_classifier, "lb", &tot_det_lb_l, LB_ERROR_CODE);

	// detect people in the left image
	if (USING_FF_CLASSIFIER) ff_detected_r = detectWithClassifier(frame_r, ff_classifier, "ff", &tot_det_ff_r, FF_ERROR_CODE);
	if (USING_PF_CLASSIFIER) pf_detected_r = detectWithClassifier(frame_r, pf_classifier, "pf", &tot_det_pf_r, PF_ERROR_CODE);
	if (USING_FB_CLASSIFIER) fb_detected_r = detectWithClassifier(frame_r, fb_classifier, "fb", &tot_det_fb_r, FB_ERROR_CODE);
	if (USING_UB_CLASSIFIER) ub_detected_r = detectWithClassifier(frame_r, ub_classifier, "ub", &tot_det_ub_r, UB_ERROR_CODE);
	if (USING_LB_CLASSIFIER) lb_detected_r = detectWithClassifier(frame_r, lb_classifier, "lb", &tot_det_lb_r, LB_ERROR_CODE);
}

void writeLog(std::string & text, enum LOG_LINE_LEVEL llevel)
{	
	// Do not write if LOG_LEVEL is greater than the line level
	if (llevel < LOG_LEVEL) return;

	// Prepare a string with an indication of the line level
	std::string log_level;
	switch (llevel)
	{
	case DEBUG:
		log_level = "[D]";
		break;
	case WARNING:
		log_level = "[W]";
		break;
	case ERROR:
		log_level = "[E]";
		break;
	case FORMAT:
		log_level = "[F]";
		break;
	case NO_LOG:
	default: // Shouldn't be triggered
		return;
	}
	
	// Open a stream to the log file
	std::ofstream log_file(LOG_FILE_NAME, std::ios_base::out | std::ios_base::app);
	log_file << getCurrentDateTime();	// write the current date and time
	log_file << log_level;				// write the line level
	log_file << " - ";					// write a separator
	log_file << text;					// write the log text
	log_file << std::endl;				// flush
}

std::string getCurrentDateTime()
{
	const int buff_size = 80;
	time_t rawtime;
	struct tm * timeinfo;
	char st[buff_size];

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(st, buff_size, DATE_TIME_FORMAT, timeinfo);

	return st;
}

bool setupClassifier(cv::CascadeClassifier & cclassifier, std::string model, std::string cname_for_log)
{
	using namespace std;

	ostringstream oss;
	oss << "trying to load: ";
	oss << model;
	writeLog(oss.str());

	// reset ostringstream (oss)
	oss.str(""); oss.clear();

	if (!cclassifier.load(model))
	{
		oss << "Error loading";
		oss << cname_for_log;
		oss << "!";
		writeLog(oss.str(), ERROR);
		
		return false;
	}
	else
	{
		oss << cname_for_log;
		oss << " loaded correctly";
		writeLog(oss.str());
	}

	LOG_DIV_LINE;
	return true;
}

std::vector<cv::Rect> detectWithClassifier(cv::Mat frame, cv::CascadeClassifier & cclassifier, std::string short_name_for_log, unsigned int * tot_det, int ecode)
{
	std::ostringstream oss;
	std::vector<cv::Rect> detected;

	try
	{
		//lb_classifier.detectMultiScale(frame, lb_detected, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));
		cclassifier.detectMultiScale(frame, detected, 1.1, 2);

		oss << "detected ";
		oss << detected.size();
		oss << " body parts using ";
		oss << short_name_for_log;
		oss << " classifier";
		writeLog(oss.str());
	}
	catch (cv::Exception e)
	{
		oss << short_name_for_log;
		oss << "_classifier.detectMultiScale thrown: ";
		oss << e.err;
		writeLog(oss.str(), ERROR);
	}
	catch (...)
	{
		oss << "Something wrong appened (error code: ";
		oss << ecode;
		oss << ")...";

		writeLog(oss.str(), ERROR);
	}

	for (size_t i = 0; i < detected.size(); ++i)
	{
		std::ostringstream file_name;
		file_name << "detection_";
		file_name << short_name_for_log;
		file_name << "_";
		file_name << (*tot_det < 100 ? "0" : "");
		file_name << (++(*tot_det) < 10 ? "0" : "");
		file_name << *tot_det;
		file_name << ".jpg";

		if (LOG_LEVEL == EVERYTHING_ENABLED)
		{
			imwrite(file_name.str(), frame(detected.at(i)));
			writeLog("written: " + file_name.str());
		}
	}

	return detected;
}

float computeDistance()
{
	return POSITION_DELTA;
}